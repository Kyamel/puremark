import os
from pathlib import Path
import re

# TODO: Implement parsing with AST from clang
# sudo apt-get install clang libclang-dev
# pip install clang


# Função para mapear tipos C para tipos Dart
def c_to_dart_type(c_type: str) ->  str:
    mapping = {
        "int": "int",
        "float": "double",
        "double": "double",
        "char*": "Pointer<Utf8>",
        "void*": "Pointer<Void>"
    }
    return mapping.get(c_type, "dynamic")  # Valor padrão: dynamic

# Função para mapear tipos C para tipos FFI
def c_to_dart_ffi_type(c_type: str) -> str:
    mapping = {
        "int": "Int32",
        "float": "Float",
        "double": "Double",
        "char*": "Pointer<Utf8>",
        "void*": "Pointer<Void>"
    }
    return mapping.get(c_type, "Void")  # Valor padrão: Void


def generate_dart_bindings(c_file: Path,
                           bidings_out_dir: Path,
                           shared_lib_out_dir: Path) -> Path:
    """
    Generates bindings for functions defined in a C file.

    :param c_file: path to filea .c.
    :param output_dir: path to write file .dart.
    """
    dart_file = Path(bidings_out_dir) / "bindings.dart"
    os.makedirs(bidings_out_dir, exist_ok=True)

    with open(c_file, "r") as source, open(dart_file, "w") as dart:
        base_name = Path(c_file).stem

        header = f"""
// PureMark Copyright 2025. All rights reserved.
// Distributed under the AGPLv3+ license. See LICENSE file for details.
//
// This file is autogenerated based on the C file:
// {c_file}
// Do not modify manually. Any modifications to the original C file will
// require regeneration of this file.

        """
        dart.write(f"{header}\n")
        dart.write("import 'dart:ffi';\nimport 'package:ffi/ffi.dart' as adv;"
                   "// For Pointer and Dynamic memory allocation.\n")
        shared_lib_out_dir_posix = Path(shared_lib_out_dir).as_posix()
        shared_lib_out_dir_final = shared_lib_out_dir_posix.split("src/app/puremark/")[1]
        dart.write(f"final dylib = DynamicLibrary.open('{shared_lib_out_dir_final}/fmrender.dll');\n\n")

        # Processar funções definidas no arquivo C
        for line in source:
            # Regex para detectar funções exportadas
            match = re.match(r"(EXPORT\s+)?([\w\*\s\*]+)\s+(\w+)\((.*?)\)", line.strip())

            if match:
                # Extraindo os detalhes da função
                return_type = match.group(2)  # Tipo de retorno
                func_name = match.group(3)   # Nome da função
                args = match.group(4)       # Argumentos da função

                # Transformar os argumentos em tipos Dart
                dart_args = []
                ffi_args = []
                if args.strip():
                    for arg in args.split(","):
                        c_type, var_name = arg.strip().rsplit(" ", 1)
                        dart_type = c_to_dart_type(c_type)
                        ffi_type = c_to_dart_ffi_type(c_type)
                        dart_args.append(f"{dart_type} {var_name}")
                        ffi_args.append(ffi_type)

                # Gerar typedefs e o binding da função
                dart.write(f"// Typedef for {func_name}\n")
                dart.write(f"typedef {func_name.capitalize()}Func = {c_to_dart_ffi_type(return_type)} Function({', '.join(ffi_args)});\n")
                dart.write(f"typedef {func_name.capitalize()} = {c_to_dart_type(return_type)} Function({', '.join([a.split(' ')[0] for a in dart_args])});\n")

                dart.write(f"// Loads {func_name} function\n")
                dart.write(f"final {func_name.capitalize()} {func_name} = dylib.lookupFunction<{func_name.capitalize()}Func, {func_name.capitalize()}>(\n")
                dart.write(f"  '{func_name}',\n")
                dart.write(");\n\n")


    return dart_file

